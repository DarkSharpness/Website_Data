---
title: 红黑树的一种实现 & 剖析
date: 2023-03-14 16:42:16
updated: 2023-03-14 23:01:16
tags: [树形结构,平衡树,STL]
categories: [算法,树形结构,平衡树]
keywords: [树形结构,平衡树,STL]
cover: https://s2.loli.net/2023/03/14/zWCE74irBUnSox3.png
mathjax: true
description: 红黑树的一种高效架构及实现。
---

红黑树是一个非常高效的数据结构。其本质是一颗平衡的二叉搜索树，可以在 $O(logn)$ 的时间内完成一次插入或者删除操作，支持在最坏 $O(logn)$ 的时间内树上进行二分查找的操作。在各种编程语言中，往往也会用红黑树算法来实现最基础的 map 类(或者其他类似的名字，例如 python 字典类)，可以通过一个 key 来查询对应的 value 。

本文不会过分地讨论红黑树平衡相关的算法，而是会具体讨论下红黑树实现的底层架构，算法问题请左转百度自行学习。本文希望能够从一些最简单的想法出发，引出一个复杂而高效的红黑树实现。

**在开始阅读文章前，请牢记以下这些核心问题与要求!**

**在开始阅读文章前，请牢记以下这些核心问题与要求!**

**在开始阅读文章前，请牢记以下这些核心问题与要求:**

Questions:
-
- 如何简化繁多的边界判定以及分支 ?
- 如何减少不必要的重复代码 ?
- 如何尽可能地减小空间占用 ?
- 如何避免模板导致的代码膨胀 ?

Requirements:
-
- 最坏 $O(n)$ 的遍历树(用迭代器)，复制另外一颗树
- 最坏 $O(logn)$ 的插入、删除、二分查找操作等等
- 均摊 $O(1)$ 的迭代器自迭代操作(++ 和 -- 双向迭代)
- 最坏 $O(1)$ 取得 begin() 和 end() 迭代器、迭代器解引用


# 回顾

先简单回顾下二叉搜索树。

## 节点

一颗二叉树的节点会保留一些必要信息。一般来说，一个节点必须要有指向左儿子和右儿子的两个指针，还有节点保存的数据，大致如下:

```C++
struct Node {
    Node *left;
    Node *right;
    value_type data;
};
```

对于红黑树，其特别地还需要保留一个节点的颜色(Color)。不难发现，保存红黑树的节点只需要 1bit 即可，但是如果用一个 bool 变量来保存，那么由于 C++ 的对齐，其将会被拓展到 8bit 甚至更多 (一般来说至少会被对齐到 4Byte 或 8Byte)。因此，存在一种节约内存的优化，即把颜色嵌入某个指针的最低或者最高位 (事实上，在 64 位机器上，指针有很多bit 都是无效信息，因为指针只需 40bit 就可以唯一标号一个 1T 内存中每一个位置，一般多余的 bit 内存管理器会用来保存其他的信息，例如内存块的大小) ，当然这涉及程序甚至是系统底层 allocator 的具体实现，一般只有非常底层、贴近操作系统 (例如Linux内核) 的代码中才会考虑。

同时，若要实现迭代器遍历的功能，则必须额外存一个指向父亲节点的指针 parent ，原因也很显然，这里举一个最简单的例子(不是说只有这个情况) : 如果当前迭代器指向叶子节点 (即当前节点左右儿子指向空) ，那么向前或向后迭代该迭代器的时候，其必须要往父节点方向走，这就需要父亲指针 parent 的存在。(你可能想问为啥迭代器不能单独存一些额外信息来避免存 parent 指针，但是容易证明这需要额外保存最长 $O(logn)$ 级别的 parent 链，这样的开销对一个本应 simple 的迭代器是不可接受的)

下面是一个演示实现代码:

```C++
/* 颜色 变量，只需一个 bit 即可 */ 
enum class Color : bool { BLACK,RED };

/* 节点主体 */
struct Node {
    Node *parent;
    Color color;
    Node *left;
    Node *right;
    value_type data;
};

```

## 搜索树

对于一颗搜索树，其显然需要保留一个根节点，或者说是指向根节点的指针。不仅如此，其也需要提供一个 allocator 来管理节点占用空间的申请与释放，还需要一个 Compare 类来负责比较两个 key-value pair 的 key (因为搜索树内部一般是按照 key 的大小顺序构建的)。当然，如果你的容器需要记录节点总数，那么还需要额外存一个 count 变量。

*题外话: 如果你还不知道如何啥是 allocator，说明你可能没怎么写过工程代码，但是别急，你可以理解为用来申请/释放内存空间的一个类，提供类似 new/delete,malloc/free 的功能。

因此，一个典型的基于搜索树类可以大致写成如下的形式:

```C++
struct tree {
    allocator Alloc;
    Compare comp;
    Node *root;
    size_t count;
};

```

## 亿朵乌云

> 动力理论肯定了热和光是运动的两种方式，现在，它的美丽而晴朗的天空却被两朵乌云笼罩了。

> 现在，红黑树那看似美丽而晴朗的应用前景，也被亿朵乌云所笼罩。

现在我们已经基本定义了红黑树的最核心的两个类 (好吧，应该是三个，算上 enum class Color 的话)。然而，问题真的解决了吗 ? 还有些许边界细节没有讨论清楚吧 ?

以下是一些是实现红黑树时常见的问题 (至少 DarkSharpness遇到了部分) :

1. 当树为空的时候，root 指向什么? 空?
1. allocator 和 Compare 往往是空类型，但是由于 C++ 要求至少会占用 1 Byte，对齐后可能就是 8 Byte，空间浪费如何解决?
1. iterator 类里面存什么? 一个指针? 还是两个?
1. 如何保证获得 begin() 和 end() 都是最坏 O(1) 的?
1. end() 迭代器理论上指向的不是这个 map 中的元素。此时如何保证 --end() 能回到 map 中?
1. 红黑树主体如此繁杂，如何尽可能避免模板类带来的代码膨胀? [(see this)](https://blog.csdn.net/zhizhengguan/article/details/113384008)


事实上，仔细思考，这里面还是有很多细节的。下面将从具体实现入手，加以分析。

# 深入

为了尽可能地优化，我们需要结合一些 C++ 和 红黑树 的 Feature 进行针对性的优化。

## 空基类优化

**针对前面的第 2 个问题**，我们可以利用C++ 中的**空基类优化** ([Empty base optimization](https://en.cppreference.com/w/cpp/language/ebo))。简单来说，虽然 C++ 要求任何类型的 sizeof 至少为 1 来保证两个不同的对象有不同的地址 (想想sizeof()是 0 的时候，数组里面不同的对象的地址情况) 。但是对于空基类 (即没有虚函数和非 static 的变量)，如果衍生类除去基类的部分 sizeof() 不是 0，且满足一些特殊的条件 (详见前面的link)，那么可以把空基类的地址设置的和衍生类第一个 sizeof 不是 0 的变量一样，这样就可以避免空类型占用空间。本例中，由于要记录树节点数量 count，所以将其 allocator 和 Compare 压缩到 count 上。

参考实现如下:
```C++
// Utilizing EBO
struct implement : allocator,Compare {
    size_t count;
};

```

**由此，我们借助了 EBO 空类型优化，解决了问题 2。**

## 节点和树的关系

节点 Node 是树 tree 的重要组成部分，而 tree 又是必须依赖于模板里面的 Compare 和 allocator的，但是，这真的意味着两者不可分离吗? 难道所有的原子操作都是依赖模板参数的? 模板代码膨胀 ~~dssq~~ 不可避免了?

最简单的，我们粗糙地考虑下红黑树的一次成功的插入 insert 操作: 首先通过树，定位到对应的插入的位置，构造并插入一个 Node，然后开始调整树的红黑关系。

**现在给你半分钟。仔细思考以上的步骤中，哪些是必须依赖模板类 tree 的，哪些是可以独立于 tree 而只依赖于 Node 而进行的。在这里，我们假设 Node 和 tree 是分离的。** 你可以带着问题先看下去。

**我们考虑前面的第 1 个问题**: root 存什么。事实上，root 是一个很特殊的指针，其指向的是红黑树的根节点。而当 root 所指向的节点改变，例如在 红黑树旋转 rotate 操作后，root 的值也应当随之改变。然而 rotate 操作修改的是相关 Node 的指针，而不能修改 root 这一个属于 tree 的指针。这便会导致如果 rotate 旋转后改变了根节点，那么你将必须要回到 tree 去修改 root，或者在 rotate 参数传入 root 指针引用。这样的代码显然是不好的，将导致 rotate 过多依赖于 tree 。事实上，如果把 root 指针嵌入某个 Node，即 root 其实是某个 Node 的指针，那么我们在 rotate 中就可以直接通过修改 Node 的指针来修改 root，从而达到脱离 tree 只借助 Node 来 rotate。

**一分钟差不多也到了吧(笑)。**从上面这个例子，我们不难看出，在把 root 嵌入 Node 以后，我们可以把 rotate 操作直接独立于 tree，只借助 Node 之间的修改操作 (一般是通过Node *间接修改)，来实现。再回到前面那个问题，在 insert 中，定位到插入位置依赖于比较函数 Compare，而构造并插入 Node 依赖于 allocator，但是调整树的红黑关系，它只需要知道 Node 的颜色，修改 Node 的属性即可了。因此，我们可以认为调整 Node 颜色这一步是独立于 tree 进行的。

但是，别忘记了，我们的 Node 目前还是依赖于树的 value_type 呢，两者独立只是我们的假设，重新看看节点最原始的定义:

```C++
/* 节点主体 */
struct Node {
    Node *parent;
    Color color;
    Node *left;
    Node *right;
    value_type data;
};

```

这就很 annoying 了。但是，仔细思索前面提及的 Node 的操作 : rotate 和 insert 后调整颜色。两者似乎...似乎有什么共性? **两者都不依赖于 value_type !** 是的，当你完成插入以后，他已经是一颗标准的二叉树了，无论怎么 rotate ，怎么调整颜色，都不会影响到 value_type。不仅如此，value_type 也不会影响到后续核心的 insert 后调整颜色。说到这，你是不是有一种感觉，感觉 Node 是一个不够原子不够本质的东西? 好像还能再提取些什么出来，其完全不依赖于 tree 所提供的模板。由此，DarkSharpness 想出了两种不同的思路: 
- 将 value_type 换成一个 void * 指针，需要时指针类型强转。
- 将 Node 拆成一个不含 value_type 的基类 Node_base 和继承了 Node_base、依赖于模板 的 Node 类。进行不依赖 tree 操作时，Node 指针安全退化为基类 Node_base 指针。

显然的，后者会略好于前者。首先，前者会多存一个指针的大小，这个开销时完全可以避免的。同时，后者用到了隐性类型转化 (派生类退化为基类) 会更加安全。最后，前者用指针简介访问存储的数据，其实会带来一定的性能开销 (访问数据相当于再经过了一层指针，而指针寻址不是很高效)。

所以，在综合多种考虑后，DarkSharpness 决定采用第二种实现: 将 Node 拆成一个不含 value_type 的基类 Node_base 和继承了 Node_base、依赖于模板 的 Node 类。进行不依赖 tree 操作时，Node 指针安全退化为基类 Node_base 指针。如下所示:

```C++
/* 基类 */
struct Node_base {
    Node_base *parent;
    Color color;
    Node_base *left;
    Node_base *right;
};

/* 派生类 */ 
template <class T>
struct Node : Node_base {
    T data;
};

```

而 rotate 等部分红黑树操作也就可以独立于模板，从而避免代码膨胀了。大致如下:

```C++

// 将当前节点旋转到父节点位置
void rotate(Node_base *ptr) {
    // ...
}

// 插入当前节点后，完成红黑树的修复(调整颜色，改变相对位置rotate)
void insert_fix(Node_base *ptr) {

}

```

总结一下，通过综合考虑红黑树的 tree 和 Node 的关系，我们把之前朴素想法的 Node 类拆成了更加本质的 Node_base 和模板派生类 Node ，从而将部分的函数直接独立于模板类 tree 实现。事实上，这部分函数占据的是红黑树的主体部分，这样的实现方式非常有助于减少代码膨胀。

# 待续

~~不会真的没人催更吧~~

~~评论区没人催更就不写咯~~

~~两周三更了，还不快打赏Orz~~
