---
title: 关于 STL iterator 的那些事
date: 2023-03-08 18:11:37
updated: 2023-03-08 21:38:37
tags: [基础知识,STL]
categories: [C++,STL]
keywords: [STL,iterator]
cover: https://s2.loli.net/2023/03/08/v39f5zd4pEeSlQc.jpg
mathjax: false
description: 关于 iterator 的实现的一些想法
---

希望您在阅读本文前对于迭代器、容器等概念已经略有了解，如果您不了解好像也没啥大关系。


# 为什么要有迭代器

> 读懂自己，迭代自己 —— [yyu](https://zhuanlan.zhihu.com/p/82644069)

## 迭代器的起源

笔者最初接触 iterator 是在学习 std::map 的时候。为了从小到大遍历访问 map 里面的元素，我们需要用到 iterator。

iterator，迭代器，顾名思义就是一个可以支持迭代的工具类，其最基础的功能就是通过自我迭代来遍历访问一个容器中的元素，即是对于 **遍历访问容器的内容的操作** 进行了封装。

这样的封装是非常有意义的，对于不同的容器，例如链表、数组、树，遍历访问的方式可能大不相同。如果没有迭代器，那么对于一些需要遍历容器的函数，例如 average() 获取容器中元素的平均值，我们需要针对每个容器数据存储的特点，设计其独有的 average() 函数。这样子不利于代码复用，而且更加容易在编写的过程中出错，甚至还容易过度暴露容器内部的细节，影响了封装性。

事实上，我们重新回到遍历访问容器中每一个元素这一个过程，其本质上可以拆成如下两个原子过程:

1. 对当前的元素(对象)执行操作
2. 将操作的对象修改为下一个元素

由此，我们可以对所有容器添加一些公有的接口，其会返回一个容器独特的迭代器，而这些迭代器都至少具有如下两个功能:

1. 访问当前位置
2. 移动到下一个位置

同时，遍历访问也是有终点的，所以我们还必须要能判断什么时候应该停止迭代，即何时到达了终点的位置，于是便有了迭代器的第三个功能: 

3. 判断两个迭代器是不是同一位置。

基于以上的这些原则，便有了 iterator 这个产物。以上三个功能，在 iterator 上分别对应的是

1. 类似指针,用 * 或 -> 访问
2. 支持 ++ (有时包括 --) 运算符
3. 可以对同类的 iterator 进行 == 或 != 运算符比较

借助 iterator ，我们可以方便的遍历容器，且无需考虑内部的细节，也可以写出适用于各种有 iterator 的函数，而不必对每个容器重载一遍这个函数。

## 线性容器的迭代器之思

如果 iterator 真的简单如此，那么为什么 vector,array 这类线性容器还要有 iterator 呢？用指针替代不就行了吗？指针的确能完美覆盖以上三个功能，而且性能不会也不可能坏于 iterator ，但 STL 依然为这些线性容器提供了 iterator ，这背后其实有更加深层的原因。

首先，笔者最早体会到的一点，也是比较次要的一点，就是指针本身不是一个类(class or struct)，它是原生数据类型。而 C++ 原生数据类型的右值是不支持 ++ 和 -- 运算符的。例如，假如一个函数 ```int *begin() ``` 返回一个int 类型指针，那么你是不能直接进行 ++begin() 的操作，因为返回的begin() 是一个右值。而对于迭代器，只要重载了 ++ 运算符，即使是返回值右值 begin() 也可以直接进行 ++ 操作。

其次，在使用迭代器的时候，我们可能会想要知道迭代器的类型，例如对于随机访问迭代器，其向前迭代 n 次可以用 += n 来一步完成，而对于链表的迭代器，其向前迭代 n 次则只能一次次地迭代来实现。如果只用指针来作为迭代器，那么我们只能获得迭代器所指向的对象类型这一个信息，并不足以用来判断迭代器的类型。而线性容器 iterator 类则不一样。尽管为了性能，其本质上只存了一个指针，并且前进/后退等操作完全等价于一个指针，但其可以借助 traits 来判断类型，只会在编译期进行类型检测，不会有运行时开销，这也将会在后面讲到。

由此可见，iterator 并不仅仅是对于指针操作的一些包装，其还利用了 traits 和 模板技术，允许在编译期检测 iterator 的信息，便于用户能够针对性的写出不同的函数。

当然，指针的思想也深深地影响了迭代器的设计，目前STL的迭代器大部分在访问元素的操作上都极其类似指针，并且线性容器的迭代器几乎拥有指针所具有的所有性质(例如支持 * ->)。

## 小总结

迭代器本质上是对于指针操作的一些包装，基于容器内部的细节实现，允许用户通过简单的迭代来遍历容器，正是 yyu 所云的 “读懂自己” 进而 “迭代自己”。同时，比起原生指针，尽管操作方式几乎一致(都可以迭代自增，判等以及访问元素)，但是其借助了 traits 的力量可以在编译器表明自己的迭代器类型，不产生运行开销的同时，便于用户进一步地根据迭代器的类型来实现不同的函数，以不同的方式迭代，可谓是更深一层的 “读懂自己，迭代自己” 。

# 迭代器进阶

## STL 迭代器基础

STL 为几乎所有常用的容器都提供了迭代器，例如 array,vector,deque,map,multimap,unordered_map,set等等。特别地(题外话，可跳)，对于 priority_queue , queue 和 stack 这三个容器适配器，其并没有对应的迭代器，因为适配器本质是限制部分的功能，将一种容器转化为另外一种容器，其只保留了原容器部分必须的功能(例如 stack 只能在 top 处操作)，而原容器并不保证允许迭代器访问。例如 std::stack 的底层容器只需要 size(),empty(),push_back(),pop_back(),back(),emplace_back() 这些接口即可，虽然标准库里面 std::stack 选择的底层容器是 std::deque 支持迭代器访问，但是仅包含这些接口的底层并不是都能支持迭代器。

对于这些迭代器，结合前面讲到的三条性质。

1. 访问当前位置
2. 移动到下一个位置
3. 判断两个迭代器是不是同一位置

其必然可以支持以下的几种操作:

``` C++
struct test { int x; }

iterator <test> i,j; // 伪代码,仅表示 i,j 是某迭代器

*i , i->x;      // 1. 访问当前位置元素,操作类似指针
i++ , ++i;      // 2. 迭代自增,有的迭代器支持自减
i == j, i != j; // 3. 判断是否相等,有的支持比较( < 等)

```

对于常见 STL 容器，我们一般可以通过成员函数 begin() 或 end() 来获得其头部迭代器和尾部迭代器，分别指向 第一个元素的位置 和 最后一个元素后面的位置(这也是为什么不能访问 end() 指向的元素) 。其类型为 容器名字::iterator ，例如对于 ```vector <int>``` ，其迭代器类型为 ```std::vector <int>::iterator``` 。对于 const 的容器，其 begin() 和 end() 返回的是const元素迭代器，即容器名字::const_iterator，其本身可以修改，迭代(不同于 const iterator)，但是其指向的元素不能被修改(类似 const 数据类 的 非const 指针，例如 const int *)。

这时，肯定有小可爱要问了: 那么对于非 const 的容器，我们怎么获得 const_iterator 来安全访问呢？这非常简单，只需要用 cbegin() 和 cend() 成员函数来访问即可。

对于部分容器，其也支持反向迭代器，即可以从最后一个元素到第一个元素反向迭代。显然地，这样容器的正向迭代器必然支持反向迭代操作。

下面将再次结合三条性质进行分析

### 1. 访问当前位置元素的性质

对于序列容器，例如 vector,deque,list，一般来说其返回迭代器访问元素的方法完全等同于该类型的指针。下面以 list 为例。

``` C++
struct test { int x; }
std::list <test> l = {test{1},test{2}};
std::list <test> iterator i = l.begin();
// 一般C++11 以后会用 auto
auto j = l.cbegin(); // const_iterator

*i; // 返回一个 test 类型可读写引用(test &)
*j; // 返回一个 test 类型只读引用(const test &)
i->x; // 相当于 (*i).x , 类似指针,类型为 int &
j->x; // 同上,但类型为 const int &

```

对于 set,multiset,unordered_set 和 unordered_multiset ，尽管其也有迭代器，但由于修改迭代器所指的元素可能会破坏内部的性质(红黑树 / hash)，因此其 iterator 和 const_iterator 本质上都是 const_iterator 都是只读不可写的。

对于 map 和 unordered_map 等，其也类似 set ，对于键值 key 不能随便修改，但是允许修改 key 对应的 value。因此，其迭代器解引用的类型是 ```std::pair <const key_type,value_type>``` ，对于 iterator 变量 i 我们可以通过 i->second 来修改当前位置 key-value pair 的 value 值。而 const_iterator 则什么都不能修改，是 read-only。

### 2. 移动到下一个位置的性质

该性质取决于迭代器的性质。

对于随机访问迭代器 (Random Access iterator)，顾名思义可以随机访问，因此其不仅可以支持最基础的 ++ ，还允许进行 -- 甚至是 + n 和 - n 以及迭代器之间相减这类操作，其本质原因是底层存储连续且有序 ，例如元素本身连续存储的 vector,array 等，或者指向元素的指针连续存储的 deque 等。

对于双向迭代器 (Bidirectional iterator)，其显然可以反向迭代进行 -- 操作，但是其略弱于随机访问迭代器，不能 + n 或者 - n。代表性的有 map,list 的迭代器

对于前向迭代器 (Forward iterator)，其只有最基础的前向迭代 ++ 操作。代表性的有 forward_list,unordered_map 的迭代器。对于此类容器，其显然也不会有反向迭代器。

### 3. 判断所指是否相等的性质

其同样取决于迭代器的性质。

对于随机访问迭代器，其往往也会支持 < > 等比较操作，本质上是比较两个元素的相对下标之差，类似指针的比较。

而对于其他的迭代器，一般都不会支持除了 != 和 = 之外的比较运算符。

## iterator_traits

咕咕咕...(待更新，欢迎催更)